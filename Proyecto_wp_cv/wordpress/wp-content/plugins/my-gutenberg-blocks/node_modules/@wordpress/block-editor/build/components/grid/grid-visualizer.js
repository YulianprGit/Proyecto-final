"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GridVisualizer = GridVisualizer;
var _clsx = _interopRequireDefault(require("clsx"));
var _element = require("@wordpress/element");
var _data = require("@wordpress/data");
var _compose = require("@wordpress/compose");
var _useBlockRefs = require("../block-list/use-block-props/use-block-refs");
var _cover = _interopRequireDefault(require("../block-popover/cover"));
var _utils = require("./utils");
var _store = require("../../store");
var _useGetNumberOfBlocksBeforeCell = require("./use-get-number-of-blocks-before-cell");
var _jsxRuntime = require("react/jsx-runtime");
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

function GridVisualizer({
  clientId,
  contentRef,
  parentLayout
}) {
  const isDistractionFree = (0, _data.useSelect)(select => select(_store.store).getSettings().isDistractionFree, []);
  const gridElement = (0, _useBlockRefs.__unstableUseBlockElement)(clientId);
  if (isDistractionFree || !gridElement) {
    return null;
  }
  const isManualGrid = parentLayout?.columnCount && window.__experimentalEnableGridInteractivity;
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(GridVisualizerGrid, {
    clientId: clientId,
    gridElement: gridElement,
    isManualGrid: isManualGrid,
    ref: contentRef
  });
}
const GridVisualizerGrid = (0, _element.forwardRef)(({
  clientId,
  gridElement,
  isManualGrid
}, ref) => {
  const [gridInfo, setGridInfo] = (0, _element.useState)(() => (0, _utils.getGridInfo)(gridElement));
  const [isDroppingAllowed, setIsDroppingAllowed] = (0, _element.useState)(false);
  const [highlightedRect, setHighlightedRect] = (0, _element.useState)(null);
  (0, _element.useEffect)(() => {
    const observers = [];
    for (const element of [gridElement, ...gridElement.children]) {
      const observer = new window.ResizeObserver(() => {
        setGridInfo((0, _utils.getGridInfo)(gridElement));
      });
      observer.observe(element);
      observers.push(observer);
    }
    return () => {
      for (const observer of observers) {
        observer.disconnect();
      }
    };
  }, [gridElement]);
  (0, _element.useEffect)(() => {
    function onGlobalDrag() {
      setIsDroppingAllowed(true);
    }
    function onGlobalDragEnd() {
      setIsDroppingAllowed(false);
    }
    document.addEventListener('drag', onGlobalDrag);
    document.addEventListener('dragend', onGlobalDragEnd);
    return () => {
      document.removeEventListener('drag', onGlobalDrag);
      document.removeEventListener('dragend', onGlobalDragEnd);
    };
  }, []);
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_cover.default, {
    className: (0, _clsx.default)('block-editor-grid-visualizer', {
      'is-dropping-allowed': isDroppingAllowed
    }),
    clientId: clientId,
    __unstablePopoverSlot: "block-toolbar",
    children: /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
      ref: ref,
      className: "block-editor-grid-visualizer__grid",
      style: gridInfo.style,
      children: isManualGrid ? (0, _utils.range)(1, gridInfo.numRows).map(row => (0, _utils.range)(1, gridInfo.numColumns).map(column => /*#__PURE__*/(0, _jsxRuntime.jsx)(GridVisualizerCell, {
        color: gridInfo.currentColor,
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)(GridVisualizerDropZone, {
          column: column,
          row: row,
          gridClientId: clientId,
          gridInfo: gridInfo,
          highlightedRect: highlightedRect,
          setHighlightedRect: setHighlightedRect
        })
      }, `${row}-${column}`))) : Array.from({
        length: gridInfo.numItems
      }, (_, i) => /*#__PURE__*/(0, _jsxRuntime.jsx)(GridVisualizerCell, {
        color: gridInfo.currentColor
      }, i))
    })
  });
});
function GridVisualizerCell({
  color,
  children
}) {
  return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
    className: "block-editor-grid-visualizer__cell",
    style: {
      boxShadow: `inset 0 0 0 1px color-mix(in srgb, ${color} 20%, #0000)`
    },
    children: children
  });
}
function GridVisualizerDropZone({
  column,
  row,
  gridClientId,
  gridInfo,
  highlightedRect,
  setHighlightedRect
}) {
  var _highlightedRect$cont;
  const {
    getBlockAttributes
  } = (0, _data.useSelect)(_store.store);
  const {
    updateBlockAttributes,
    moveBlocksToPosition,
    __unstableMarkNextChangeAsNotPersistent
  } = (0, _data.useDispatch)(_store.store);
  const getNumberOfBlocksBeforeCell = (0, _useGetNumberOfBlocksBeforeCell.useGetNumberOfBlocksBeforeCell)(gridClientId, gridInfo.numColumns);
  const ref = useDropZoneWithValidation({
    validateDrag(srcClientId) {
      const attributes = getBlockAttributes(srcClientId);
      const rect = new _utils.GridRect({
        columnStart: column,
        rowStart: row,
        columnSpan: attributes.style?.layout?.columnSpan,
        rowSpan: attributes.style?.layout?.rowSpan
      });
      const isInBounds = new _utils.GridRect({
        columnSpan: gridInfo.numColumns,
        rowSpan: gridInfo.numRows
      }).containsRect(rect);
      return isInBounds;
    },
    onDragEnter(srcClientId) {
      const attributes = getBlockAttributes(srcClientId);
      setHighlightedRect(new _utils.GridRect({
        columnStart: column,
        rowStart: row,
        columnSpan: attributes.style?.layout?.columnSpan,
        rowSpan: attributes.style?.layout?.rowSpan
      }));
    },
    onDragLeave() {
      // onDragEnter can be called before onDragLeave if the user moves
      // their mouse quickly, so only clear the highlight if it was set
      // by this cell.
      setHighlightedRect(prevHighlightedRect => prevHighlightedRect?.columnStart === column && prevHighlightedRect?.rowStart === row ? null : prevHighlightedRect);
    },
    onDrop(srcClientId) {
      setHighlightedRect(null);
      const attributes = getBlockAttributes(srcClientId);
      updateBlockAttributes(srcClientId, {
        style: {
          ...attributes.style,
          layout: {
            ...attributes.style?.layout,
            columnStart: column,
            rowStart: row
          }
        }
      });
      __unstableMarkNextChangeAsNotPersistent();
      moveBlocksToPosition([srcClientId], gridClientId, gridClientId, getNumberOfBlocksBeforeCell(column, row));
    }
  });
  const isHighlighted = (_highlightedRect$cont = highlightedRect?.contains(column, row)) !== null && _highlightedRect$cont !== void 0 ? _highlightedRect$cont : false;
  return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
    ref: ref,
    className: (0, _clsx.default)('block-editor-grid-visualizer__drop-zone', {
      'is-highlighted': isHighlighted
    })
  });
}
function useDropZoneWithValidation({
  validateDrag,
  onDragEnter,
  onDragLeave,
  onDrop
}) {
  const {
    getDraggedBlockClientIds
  } = (0, _data.useSelect)(_store.store);
  return (0, _compose.__experimentalUseDropZone)({
    onDragEnter() {
      const [srcClientId] = getDraggedBlockClientIds();
      if (srcClientId && validateDrag(srcClientId)) {
        onDragEnter(srcClientId);
      }
    },
    onDragLeave() {
      onDragLeave();
    },
    onDrop() {
      const [srcClientId] = getDraggedBlockClientIds();
      if (srcClientId && validateDrag(srcClientId)) {
        onDrop(srcClientId);
      }
    }
  });
}
//# sourceMappingURL=grid-visualizer.js.map