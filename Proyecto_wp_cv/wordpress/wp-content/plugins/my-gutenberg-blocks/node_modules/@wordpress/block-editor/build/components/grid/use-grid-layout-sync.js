"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useGridLayoutSync = useGridLayoutSync;
var _data = require("@wordpress/data");
var _element = require("@wordpress/element");
var _store = require("../../store");
var _utils = require("./utils");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

function useGridLayoutSync({
  clientId: gridClientId
}) {
  const {
    gridLayout,
    blockOrder
  } = (0, _data.useSelect)(select => {
    var _getBlockAttributes$l;
    const {
      getBlockAttributes,
      getBlockOrder
    } = select(_store.store);
    return {
      gridLayout: (_getBlockAttributes$l = getBlockAttributes(gridClientId).layout) !== null && _getBlockAttributes$l !== void 0 ? _getBlockAttributes$l : {},
      blockOrder: getBlockOrder(gridClientId)
    };
  }, [gridClientId]);
  const {
    getBlockAttributes
  } = (0, _data.useSelect)(_store.store);
  const {
    updateBlockAttributes,
    __unstableMarkNextChangeAsNotPersistent
  } = (0, _data.useDispatch)(_store.store);
  (0, _element.useEffect)(() => {
    const updates = {};
    const {
      columnCount,
      rowCount = 2
    } = gridLayout;
    const isManualGrid = !!columnCount;
    if (isManualGrid) {
      const rects = [];
      let cellsTaken = 0;

      // Respect the position of blocks that already have a columnStart and rowStart value.
      for (const clientId of blockOrder) {
        const attributes = getBlockAttributes(clientId);
        const {
          columnStart,
          rowStart,
          columnSpan = 1,
          rowSpan = 1
        } = attributes.style?.layout || {};
        cellsTaken += columnSpan * rowSpan;
        if (!columnStart || !rowStart) {
          continue;
        }
        rects.push(new _utils.GridRect({
          columnStart,
          rowStart,
          columnSpan,
          rowSpan
        }));
      }

      // Ensure there's enough rows to fit all blocks.
      const minimumNeededRows = Math.ceil(cellsTaken / columnCount);
      if (rowCount < minimumNeededRows) {
        updates[gridClientId] = {
          layout: {
            ...gridLayout,
            rowCount: minimumNeededRows
          }
        };
      }

      // When in manual mode, ensure that every block has a columnStart and rowStart value.
      for (const clientId of blockOrder) {
        const attributes = getBlockAttributes(clientId);
        const {
          columnStart,
          rowStart,
          columnSpan,
          rowSpan
        } = attributes.style?.layout || {};
        if (columnStart && rowStart) {
          continue;
        }
        const [newColumnStart, newRowStart] = getFirstEmptyCell(rects, columnCount, minimumNeededRows, columnSpan, rowSpan);
        rects.push(new _utils.GridRect({
          columnStart: newColumnStart,
          rowStart: newRowStart,
          columnSpan,
          rowSpan
        }));
        updates[clientId] = {
          style: {
            ...attributes.style,
            layout: {
              ...attributes.style?.layout,
              columnStart: newColumnStart,
              rowStart: newRowStart
            }
          }
        };
      }
    } else {
      // When in auto mode, remove all of the columnStart and rowStart values.
      for (const clientId of blockOrder) {
        const attributes = getBlockAttributes(clientId);
        const {
          columnStart,
          rowStart,
          ...layout
        } = attributes.style?.layout || {};
        // Only update attributes if columnStart or rowStart are set.
        if (columnStart || rowStart) {
          updates[clientId] = {
            style: {
              ...attributes.style,
              layout
            }
          };
        }
      }
    }
    if (Object.keys(updates).length) {
      __unstableMarkNextChangeAsNotPersistent();
      updateBlockAttributes(Object.keys(updates), updates, /* uniqueByBlock: */true);
    }
  }, [
  // Actual deps to sync:
  gridClientId, gridLayout, blockOrder,
  // Needed for linter:
  __unstableMarkNextChangeAsNotPersistent, getBlockAttributes, updateBlockAttributes]);
}
function getFirstEmptyCell(rects, columnCount, rowCount, columnSpan = 1, rowSpan = 1) {
  for (let row = 1; row <= rowCount; row++) {
    for (let column = 1; column <= columnCount; column++) {
      const rect = new _utils.GridRect({
        columnStart: column,
        rowStart: row,
        columnSpan,
        rowSpan
      });
      if (!rects.some(r => r.intersectsRect(rect))) {
        return [column, row];
      }
    }
  }
  return [1, 1];
}
//# sourceMappingURL=use-grid-layout-sync.js.map